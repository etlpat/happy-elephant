#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>










//void pri(int* arr)//形参已经是指针
//{
//	printf("%d\n", sizeof(arr));//8(64位系统)
//}
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n",sizeof(arr));//64
//	pri(arr);
//	return 0;
//}







//////////////////////////////////////        1.字符指针




/////////     可以不用数组，而是用指针p来描述字符串，此时的字符串为一个常量字符串
//int main()
//{
//	                   //"abcdef"是一个常量字符串
//	char* p = "abcdef";//可以用一个[指针]来充当[首元素地址]来描述一个[常量字符串]
//	printf("%c\n", *p);
//	printf("%s\n", p);//%s的逻辑是运行到'\0'为止
//	
//	*p = 'W';         //这里p描述的是[常量字符串]的首元素地址,不能随便赋值
//	printf("%s\n", p);//会报错：  引发了异常: 写入访问权限冲突
//	return 0;
//}

//////////  所以最好使用const修饰指针,防止指针被改动
//int main()
//{
//	const char* p = "abcdef"; //让代码更安全
//	printf("%s", p);
//	return 0;
//}




/////////////    关于常量字符串的题目
//int main()
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	const char* p1 = "abcdef";
//	const char* p2 = "abcdef";
//	if (arr1 == arr2)
//		printf("1相等\n");
//	else
//		printf("1不相等\n");
//	if (p1 == p2)
//		printf("2相等\n");
//	else
//		printf("2不相等\n");
//	return 0;
//}
////结果 1不相等 2相等
/// 1:因为是两个数组，其首元素地址肯定不相同
/// 2:这里是常量字符串，因为其不会改变，所以为了节省空间，规定常量字符串再内存中只有一个，储存于内存的静态区。
/// 常量字符串的首元素地址 p1 p2 都相同 ；但是地址p1 p2的地址(int**)不同



















////////////////////////////////////           2.指针数组（用于存放指针的数组）

//int main()//诸如此类就是指针数组
//{
//	int a = 1, b = 2, c = 3, d = 4;
//	int* pa[4] = { &a,&b,&c,&d };
//	char* pch[10] = { 0 };
//  int** Ppa = {0};
//	return 0;
//}




////////   指针数组的应用：存放数组首元素地址
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 6,7,8,9,0 };
//	int arr3[] = { 4,5,6,7,8 };
//	int* Parr[] = {arr1,arr2,arr3};
//	int i = 0, j = 0;
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(Parr[i] + j));
//		}
//		printf("\n");
//	}
//	return 0;
//}


















////////////////////////////////////                     3.数组指针（用于存放数组的指针）


///////////////////////      数组指针的定义方法 int(*p)[10] = &arr; p为数组指针;
///////////////////////        (*p)外边的是指针指向对象的类型，（）内*p代表它是指针，p是指针变量的名字
//
//int main()
//{
//	int* pa = NULL;       //pa是整形指针 - 指向整形的指针 - 可以存放整形的地址
//	char* pch = NULL;    //pch是字符指针 - 指向字符的指针 - 可以存放字符的地址
//	                   //数组指针 - 指向数组的指针 - 存放数组的地址
//	//arr - 首元素地址
//	//&arr[0] - 首元素地址
//	//&arr - 数组的地址
//
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
//	int(*p)[10] = &arr;      // 所以用int(*p)[10]表示，其中int[10]是数组的类型
//	//若int* p,无法于整形指针区别；若int *p[10]，[]的优先级比*高，先和[]结合，表示存放指针的数组；
//	//上面p为数组指针
//
//	return 0;
//}



///////////////////////   区分下面p1 p2
////int *p1[10] ---- 存放指针的数组 -- 指针数组
////int(*p2)[10] --- 指向数组的指针 -- 数组指针 //p2的类型是 int(*)[10]





//////////////////     题目：标出pa的类型
//int main()
//{
//	char* arr[5];
//    ////问：###pa### = &arr ?                 //该指针指向数组的类型为char*[5]
//	char* (*pa)[5] = &arr;  ////  (*pa)代表pa变量为指针；外面的char*[5]是指针指向对象的类型 
//	return 0;
//}






//////////////////////////数组指针的简单应用
//// 
////////////////////  数组指针int(*p)[10]=&arr;  *p的作用相当于arr
///////////////////           int arr[10]
//
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
//	int(*pa)[10] = &arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		//       /////用法1，arr[i]变成(*p)[i]，相当于arr[i]
//		//printf("%d", (*pa)[i]);
//	           
//		//       ////用法2，pa解引用为*pa，相当于arr,可以当首元素地址使用
//		//printf("%d", *(*pa + i));
//	}
//}







///////////////////////数组指针具体应用
/////////（原理是：二维数组名 为 第一行的一维数组的地址）
//
//           ////二维数组标明行列才能把元素正确放进形参处创建的数组
//void pri1(int ARR[3][3], int x, int y)//（参数的数组的形式）
//{
//	int i, j;
//	for (i = 0; i < x; i++)
//	{
//		for (j = 0; j < y; j++)
//		{
//			printf("%d ", ARR[i][j]);
//		}
//		printf("\n");
//	}
//}
//
////二维数组int arr[3][3]传参，传的是（二维数组首元素）地址 ，是（一维数组）的地址，是int(*p)[3]
//void pri2(int(*p)[3], int x, int y)//（参数是指针的形式）
//{
//	int i, j;
//	for (i = 0; i < x; i++)
//	{
//		for (j = 0; j < y; j++)
//		{
//			             /////因为p[i]是以p为首元素地址访问下标为i的元素 == *(p+i)
//			             //所以可以写成下面几种形式
//			printf("%d ", *(*(p + i) + j));
//			printf("%d ", (*(p + i))[j]);
//			printf("%d ", *(p[i] + j));
//			printf("%d ", p[i][j]);   //相当于(p[i])[j] == (每行的数组名)[j]
//		}
//		printf("\n");
//	}
//}
//
//int main()
//{
//	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
//	pri1(arr, 3, 3);//数组名传参，数组形式接收
//	printf("\n");
//
//
//	//arr -- 二维数组名 -- 首元素地址
//	//二维数组的首元素是什么？
//	//这里要把二维数组看作一维数组，每一行（每一个{}）看作一个元素
//	//那么arr[3][3]有三个元素，每一行是一个元素
//	//那么{{1,2,3},{4,5,6},{7,8,9}}的首元素就是{1,2,3}，是一维数组
//	//二维数组数组名是首元素地址，就是第一行的地址，是一个一维数组的地址
//	pri2(arr, 3, 3);
//    printf("\n");
//
//	return 0;
//}






/////////////////下标引用操作符[]的本质 *(p + i)
//////////p为指针，p[i]表示 -- 以p为起始地址，访问下标为i的元素
//////////         p[i] == *(p + i)
// 
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i < 5; i++)
//	{
//		printf("%d ", arr[i]);//数组名+下标引用操作符
//		printf("%d ", *(arr + i));//数组首元素地址+下标，解引用
//		printf("%d ", *(p + i));//和上一个一样
//		printf("%d ", p[i]);//以p为起始地址，访问下标为i的元素
//		 
//		                  //////由上面得出，p[i] == *(p + i)
//		printf("\n");
//	}
//	return 0;
//}






////////////////////区分下面是什么 -- [] 优先级比 *   高
// 
////  int *p                   //是一个指针，指向整形
////  int arr[5]               //是一个5个元素的整形数组
////  int *parr1[10]           //是一个数组，有10个元素，元素类型是int*，parr1是指针数组
////  int (*parr2)[10]         //是一个指针，指向一个有10个整形元素的数组                                 //parr2的类型为 int(* )[10]
////  int (*parr3[10])[5]      //是一个有10个元素的数组，每个元素是个数组指针，指向有5个整形元素的数组    //去掉parr3[10]，剩下的就是元素类型 int(* )[5]






















////////////////////////////////////            4.数组传参和指针传参




















////////////////////////////////////5.函数指针
////////////////////////////////////6.函数指针数组
////////////////////////////////////7.指向函数指针数组的指针
////////////////////////////////////8.回调函数
////////////////////////////////////9.指针和数组面试题的解析