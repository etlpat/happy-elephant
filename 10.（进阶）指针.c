#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>










//void pri(int* arr)//形参已经是指针
//{
//	printf("%d\n", sizeof(arr));//8(64位系统)
//}
//int main()
//{
//	int arr[10] = { 0 };
//	printf("%d\n",sizeof(arr));//64
//	pri(arr);
//	return 0;
//}







//////////////////////////////////////        1.字符指针




/////////     可以不用数组，而是用指针p来描述字符串，此时的字符串为一个常量字符串
//int main()
//{
//	                   //"abcdef"是一个常量字符串
//	char* p = "abcdef";//可以用一个[指针]来充当[首元素地址]来描述一个[常量字符串]
//	printf("%c\n", *p);
//	printf("%s\n", p);//%s的逻辑是运行到'\0'为止
//	
//	*p = 'W';         //这里p描述的是[常量字符串]的首元素地址,不能随便赋值
//	printf("%s\n", p);//会报错：  引发了异常: 写入访问权限冲突
//	return 0;
//}

//////////  所以最好使用const修饰指针,防止指针被改动
//int main()
//{
//	const char* p = "abcdef"; //让代码更安全
//	printf("%s", p);
//	return 0;
//}




/////////////    关于常量字符串的题目
//int main()
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	const char* p1 = "abcdef";
//	const char* p2 = "abcdef";
//	if (arr1 == arr2)
//		printf("1相等\n");
//	else
//		printf("1不相等\n");
//	if (p1 == p2)
//		printf("2相等\n");
//	else
//		printf("2不相等\n");
//	return 0;
//}
////结果 1不相等 2相等
/// 1:因为是两个数组，其首元素地址肯定不相同
/// 2:这里是常量字符串，因为其不会改变，所以为了节省空间，规定常量字符串再内存中只有一个，储存于内存的静态区。
/// 常量字符串的首元素地址 p1 p2 都相同 ；但是地址p1 p2的地址(int**)不同












////////////////////////////////////           2.指针数组（用于存放指针的数组）

//int main()//诸如此类就是指针数组
//{
//	int a = 1, b = 2, c = 3, d = 4;
//	int* pa[4] = { &a,&b,&c,&d };
//	char* pch[10] = { 0 };
//  int** Ppa = {0};
//	return 0;
//}




////////   指针数组的应用：存放数组首元素地址
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 6,7,8,9,0 };
//	int arr3[] = { 4,5,6,7,8 };
//	int* Parr[] = {arr1,arr2,arr3};
//	int i = 0, j = 0;
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 5; j++)
//		{
//			printf("%d ", *(Parr[i] + j));
//		}
//		printf("\n");
//	}
//	return 0;
//}















 









////////////////////////////////////                     3.数组指针（用于存放数组的指针）


///////////////////////      数组指针的定义方法 int(*p)[10] = &arr; p为数组指针;
///////////////////////        (*p)外边的是指针指向对象的类型，（）内*p代表它是指针，p是指针变量的名字
//
//int main()
//{
//	int* pa = NULL;       //pa是整形指针 - 指向整形的指针 - 可以存放整形的地址
//	char* pch = NULL;    //pch是字符指针 - 指向字符的指针 - 可以存放字符的地址
//	                   //数组指针 - 指向数组的指针 - 存放数组的地址
//	//arr - 首元素地址
//	//&arr[0] - 首元素地址
//	//&arr - 数组的地址
//
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
//	int(*p)[10] = &arr;      // 所以用int(*p)[10]表示，其中int[10]是数组的类型
//	//若int* p,无法于整形指针区别；若int *p[10]，[]的优先级比*高，先和[]结合，表示存放指针的数组；
//	//上面p为数组指针
//
//	return 0;
//}



///////////////////////   区分下面p1 p2
////int *p1[10] ---- 存放指针的数组 -- 指针数组
////int(*p2)[10] --- 指向数组的指针 -- 数组指针





//////////////////     题目：标出pa的类型
//int main()
//{
//	char* arr[5];
//    ////问：###pa### = &arr ?                 //该指针指向数组的类型为char*[5]
//	char* (*pa)[5] = &arr;  ////  (*pa)代表pa变量为指针；外面的char*[5]是指针指向对象的类型
//	return 0;
//}







//////////////////////////数组指针的简单应用
//// 
////////////////////  数组指针int(*p)[10]=&arr;  *p的作用相当于arr
///////////////////           int arr[10]
//
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
//	int(*pa)[10] = &arr;
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		//       /////用法1，arr[i]变成(*p)[i]，相当于arr[i]
//		//printf("%d", (*pa)[i]);
//	           
//		//       ////用法2，pa解引用为*pa，相当于arr,可以当首元素地址使用
//		//printf("%d", *(*pa + i));
//	}
//}




void pri1(int ARR[3][3], int x, int y)//用数组接受，标清行列才能把元素正确放进形参数组
{
	int i, j;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%d ", ARR[i][j]);
		}
		printf("\n");
	}
}


//二维数组是int arr[3][3]
//二维数组传参，传的是二维数组首元素地址 ，是一维数组的地址，是int(*p)[3]
void pri2(int(*p)[3], int x, int y)
{
	int i, j;
	for (i = 0; i < x; i++)
	{
		*(p+i)
	}
}

int main()
{
	int arr[3][3] = { {1,2,3},{4,5,6},{7,8,9} };
	pri1(arr, 3, 3);//数组名传参，数组接收


	//arr -- 二维数组名 -- 首元素地址
	//二维数组的首元素是什么？
	//这里要把二维数组看作一维数组，每一行（每一个{}）看作一个元素
	//那么arr[3][3]有三个元素，每一行是一个元素
	//那么{{1,2,3},{4,5,6},{7,8,9}}的首元素就是{1,2,3}，是一维数组
	//二维数组数组名是首元素地址，就是第一行的地址，是一个一维数组的地址
	pri2(arr, 3, 3);
}








////////////////////////////////////4.数组传参和指针传参
////////////////////////////////////5.函数指针
////////////////////////////////////6.函数指针数组
////////////////////////////////////7.指向函数指针数组的指针
////////////////////////////////////8.回调函数
////////////////////////////////////9.指针和数组面试题的解析