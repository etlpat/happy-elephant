#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>



/////////////////        （题目1.）
/////////////////       分析sizeof()计算的数组和指针相关的大小
/////////////////       秘诀是分析处[数组名的意义是什么]


////数组名是首元素地址（仅有两个例外，其他所以数组名都是首元素地址）
////1.sizeof(数组名)
////2.&数组名
////声明两种情况，是死的，数组名的地方只能是数组名，不能进行任何操作，如+0


//int main()
//{
//	///////   一维数组
//
//
//	//////整形数组(sizeof())
//	//int a[] = { 1,2,3,4 };
//	//printf("%d\n", sizeof(a));         // 16  --  sizeof(数组名)，计算数组总大小，a是整个数组的地址
//	//printf("%d\n", sizeof(a + 0));     // 4/8 --  sizeof(a+0)斌不符合sizeof(数组名)的形式，a是首元素地址
//	//printf("%d\n", sizeof(*a));        // 4   --  a是首元素地址，*a是首元素
//	//printf("%d\n", sizeof(a + 1));     // 4/8 --  a+1是第二个元素地址
//	//printf("%d\n", sizeof(a[1]));      // 4   --  a[1]是整形
//	//printf("%d\n", sizeof(&a));        // 4/8 --  &a是数组的地址，地址大小就是4/8
//	//printf("%d\n", sizeof(*&a));       // 16  --  &a已经说明a是整个数组,再*&a还是数组
//	//printf("%d\n", sizeof(&a + 1));    // 4/8 --  &a是整个数组的地址，&a+1是跳过整个数组后的地址，但还是地址，4/8
//	//printf("%d\n", sizeof(&a[0]));     // 4/8 --  []优先级高，a[0]是首元素，&a[0]是地址
//	//printf("%d\n", sizeof(&a[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符数组(sizeof())
//	//char c[] = { 'a','b','c','d','e','f' };
//	//printf("%d\n", sizeof(c));         // 6   --  计算数组大小，每个字符1字节
//	//printf("%d\n", sizeof(c + 0));     // 4/8 --  地址+0还是地址，4/8
//	//printf("%d\n", sizeof(*c));        // 1   --  字符
//	//printf("%d\n", sizeof(c[1]));      // 1   --  字符
//	//printf("%d\n", sizeof(&c));        // 4/8 --  数组的地址，还是地址4/8
//	//printf("%d\n", sizeof(&c + 1));    // 4/8 --  &c是整个数组的地址，&c+1跳出了数组，但还是地址，4/8
//	//printf("%d\n", sizeof(&c[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符数组(strlen())
//	////strlen()计算模式：从地址起始位置开始，向后1字节1字节的找，直到找到'\0'停止，长度不包含'\0'
//	//char c[] = { 'a','b','c','d','e','f' };
//	//printf("%d\n", strlen(c));         // 随机值 --  c是首元素地址，从首元素开始向后数
//	//printf("%d\n", strlen(c + 0));     // 随机值 --  和上一个完全相同
//	////printf("%d\n", strlen(*c));      // 非法访问 --  strlen接收地址，'a'-97，把97转换为地址访问，但是内存中没有这块空间，非法访问
//	////printf("%d\n", strlen(c[1]));    // 非法访问 --  同上
//	//printf("%d\n", strlen(&c));        // 随机值 --  和上面随机值相同
//	//printf("%d\n", strlen(&c + 1));    // 随机值 --  比上面随机值少6，跳过了一个数组
//	//printf("%d\n", strlen(&c[0] + 1)); // 随机值 --  比上面随机值少1
//
//
//	//////字符串(sizeof())
//	//char c[] = "abcdef";
//	//printf("%d\n", sizeof(c));         // 7   --  计算字符串所占空间大小，与是否是'\0'无关
//	//printf("%d\n", sizeof(c + 0));     // 4/8 --  不符合sizeof(数组名)形式，是地址
//	//printf("%d\n", sizeof(*c));        // 1   --  字符
//	//printf("%d\n", sizeof(c[1]));      // 1   --  字符
//	//printf("%d\n", sizeof(&c));        // 4/8 --  数组的地址，还是地址
//	//printf("%d\n", sizeof(&c + 1));    // 4/8 --  &c是整个数组的地址，&c+1跳出了数组，但还是地址
//	//printf("%d\n", sizeof(&c[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符串(strlen())
//	//char c[] = "abcdef";
//	//printf("%d\n", strlen(c));         //   6      --  strlen()遇'\0'停止
//	//printf("%d\n", strlen(c + 0));     //   6      --  和上面同理
//	////printf("%d\n", strlen(*c));      // 非法访问 --  strlen接收地址，'a'-97，不是地址
//	////printf("%d\n", strlen(c[1]));    // 非法访问 --  相当于传了98并将其转化为地址，但内存中并无98这块空间
//	//printf("%d\n", strlen(&c));        //   6      --  strlen从起始位置开始计数，数组地址起始位置和首元素地址起始位置相同；
//	////                                                ////#但是这里会警告：因为strlen()参数默认类型为const char* ，但是这里&c传递的是数组地址char(*c)[7]，警报类型不兼容
//	////                                                ////但是传递过去自动强制类型转换，二者起始位置相同，结果仍然相同
//	//printf("%d\n", strlen(&c + 1));    // 随机值   --  跳出字符串，遇到'\0'的地点未知；且和上一个一样，有警告
//	//printf("%d\n", strlen(&c[0] + 1)); //   5      --  地址+1，少一个元素 
//	//printf("\n");
//
//
//	////////常量字符串(sizeof())
//	////直接用一个指针接收一个字符串时，该字符串是个常量字符串，不能改变；指针存放常量字符串的首元素地址
//	//char* p = "abcdef";
//	//printf("%d\n", sizeof(p));         // 4/8 --  p是常量字符串的首元素地址
//	//printf("%d\n", sizeof(p + 1));     // 4/8 --  地址+1，还是地址
//	//printf("%d\n", sizeof(*p));        // 1   --  a字符
//	//printf("%d\n", sizeof(p[0]));      // 1   --  a字符，p[0]==*(p+0),[]适用于所有指针
//	//printf("%d\n", sizeof(&p));        // 4/8 --  二级指针，还是地址
//	//printf("%d\n", sizeof(&p + 1));    // 4/8 --  二级指针+1，还是地址
//	//printf("%d\n", sizeof(&p[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	////////常量字符串(strlen())
//	//char* p = "abcdef";
//	//printf("%d\n", strlen(p));         // 6
//	//printf("%d\n", strlen(p + 1));     // 5 
//	////printf("%d\n", strlen(*p));      // 非法访问 
//	////printf("%d\n", strlen(p[0]));    // 非法访问
//	//printf("%d\n", strlen(&p));        // 随机值 --  p是地址,假设为0x0112ff46，&p是p的地址，strlen(&p)是把地址p当作字符串来计算，由于地址小端存储，所以计算 46 ff 12 01，之后就是随机值，知道遇到'\0'==0就停止
//	//printf("%d\n", strlen(&p + 1));    // 随机值
//	//printf("%d\n", strlen(&p[0] + 1)); // 5
//	//printf("\n");
//
//
//	return 0;
//}

//int main()
//{
//	///////   方法还是和上面一样，sizeof(数组名)/&数组名，数组名才代表整个数组，其他时候都代表首元素 地址
//	// /////
//	///////   二维数组：
//	///////   假如int a[3][3]={{1,2,3},{4,5,6},{7,8,9}};
//	///////   第一行元素a[0][i]，第二行元素a[1][i]，第三行元素a[2][i]，所以a[0]、a[1]、a[2]可看作每行数组的数组名
//	///////   因为二维数组的三个元素是a[0]、a[1]、a[2]，所以二维数组每给个元素是一个一维数组
//
//
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(a));             // 48
//	printf("%d\n", sizeof(a[0][0]));       // 4
//	printf("%d\n", sizeof(a[0]));          // 16  -- a[0]是二维数组首元素，是第一行一维数组的数组名，数组名单独放到sizeof()中，计算的是数组大小
//	printf("%d\n", sizeof(a[0] + 1));      // 4/8 -- a[0]不是单独放在sizeof()内部，那么数组名a[0]就代表首元素地址
//	printf("%d\n", sizeof(*(a[0] + 1)));   // 4   -- 同上方法数组名+1相当于首元素地址+1；或者直接相当于a[0][1]
//	printf("%d\n", sizeof(a + 1));         // 4/8 -- a是二维数组名，a+1相当于第二个一维数组的地址
//	printf("%d\n", sizeof(*(a + 1)));      // 16  -- 第二行的地址解引用相当于第二行，相当于数组；或者直接a[1]
//	printf("%d\n", sizeof(&a[0] + 1));     // 4/8 -- 第二行的地址
//	printf("%d\n", sizeof(*(&a[0] + 1)));  // 16  -- 第二行的大小
//	printf("%d\n", sizeof(*a));            // 16  -- 首元素解引用，就是第一行
//	printf("%d\n", sizeof(a[3]));          // 16 #坑# 因为sizeof()内的表达式不会真实计算，只是根据类型计算大小，所以a[3]和a[0]没区别
//
//
//	return 0;
//}