#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

 




/////////////////////////////////////////////////////////////////////////结构体////////////////////////////////////////////////////////////////////////////////



////////////////////        1.结构体类型的声明
// 
////结构体是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量
//
// struct tag  //结构体标签
// {
//  	number_list;//成员列表
//
// }variable_list;//变量列表




////声明一个结构体类型
////声明一个学生类型，是像通过学生类型来创建一个学生变量（对象）
////描述学生：属性――名字+电话+性别+年龄
//struct stu
//{
//	char name[20];//名字
//	char tele[12];//电话
//	char sex[10];//性别
//	int age;//年龄
//
//}s3, s4;//全局结构体变量
//
//int main()
//{
//	//创建的结构体变量
//	struct stu s1;
//	struct stu s2;
//	
//	return 0;
//}





//////匿名结构体类型（没写结构体标签）
//struct
//{
//	int a;
//	char b;
//	float c;
//}x, arr[10], * p;
//////上面是匿名结构体（变量、数组、指针）
//////匿名结构体类型只能在这里创建一次全局变量
//////之后由于没有名字，不能在其他地方创建变量

















////////////////////        2.结构体的自引用





////在结构体中包含一个（和该结构体类型本身一致）的成员时，不能直接引这个结构体变量，要通过指针的形式来实现
//
// 
//////代码1（不可行）
//struct Node
//{
//	int date;
//	struct Node next;
//};
////如果是上面那样，sizeof(struct Node)则为无穷大
////（相当于没有结束条件的死循环递归）
//
//
//////代码2（可行）
//struct Node
//{
//	int date;
//	struct Node* next;
//};
////指针大小是可以确定的，可行






//////结构体成员自引用时，可以这样类型重定义：
//////代码1
//typedef struct Node
//{
//	int date;
//	struct Node* next;
//}Node;
// 
//
//////但是不允许这样类型重定义：
//////代码2
//typedef struct Node
//{
//	int date;
//	Node* next;
//}Node;
//
//
//////更不允许这样匿名类型重定义：
//////代码3
//typedef struct
//{
//	int date;
//	Node* next;
//}Node;
//
////因为程序从上向下执行，在结尾重定义类型名称，若像代码2、3那样在定义之前先引用，就会err

















////////////////////        3.结构体变量的定义和初始化


//struct T
//{
//	double d;
//	short b;
//};
//
//struct S
//{
//	char c;
//	int a;
//	struct T st;
//	char arr[10];
//};
//
//int main()
//{
//	struct S s = { 'c',124 ,{3.14,12},"hello" };
//	printf("%c %d %lf %d %s", s.c, s.a, s.st.d, s.st.b, s.arr);
//	return 0;
//}

















////////////////////        4.结构体内存对齐



////////# 1.第一个成员默认在与结构体变量偏移量为0的地址处
////
////////# 2.其他成员变量要对齐到（给自对齐数）的整数倍的地址处
////
////
////////对齐数 = (编译器默认对齐数)和(该成员大小）两个值中的较小值
////////          VS中对齐数默认值为8
////////          gcc没有默认对齐数
//////////e.g. char类型大小为1，VS默认8，取1为对齐数，char类型成员可放到偏移量为 1,2,3,4,5,6...地址处
//////////e.g. int类型大小为4，VS默认8，取4为对齐数，int类型成员可放到偏移量为 4,8,12,16...地址处
////
//// 
////////# 3.结构体总体大小为最大对齐数的整数倍 (每个成员变量都有一个对齐数)
////
////////# 4.如果结构体A嵌套了结构体B的情况，嵌套结构体B对齐到【"B自己的成员"的最大对齐数的整数倍处】，
////////    结构体A的整体大小就是所有最大对齐数（含嵌套类型结构体B的对齐数）的整数倍
////
////////# 5.按照结构体对齐方式排列出的空间，没被占用的相当于浪费掉，不存放其他的东西了
////
//// 
////
//////// 既然内存对齐浪费空间，为什么存在内存对齐？
////////   大部分资料都是如是说的：
//////// 1.平台原因（移植原因）：不是所以硬件平台都能访问任意地址上的任意数据；某些硬件平台只能
////////                         在某些地址处取某些特定类型的数据，否则抛出硬件问题。
//////// 2.性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于：为了访问未对齐的
////////             内存，处理器需要操作两次内存访问；而对齐的内存访问仅需要一次访问
//////// 总体来说：
////////          【结构体的内存对齐是拿空间来换取时间的做法】
//
//
//////////【设计结构体的小技巧】：
////// 在设计结构体的时候，我们【既要满足对齐，又要节省空间】，如何做到？
//////【让占用空间小的成员尽量集中在一起】
////// 如下，S1 S2成员一样，S2占用内存更小
//
//
//
////////////【修改默认对齐数】
//////默认对齐数设置成4
//////#pragma pack(4)
//////
//////()内不填，把对齐数改回默认
//////#pragma pack()






///////【练习】
///////下面数字代表各成员的所在位置偏移量，以及结构体的总大小
//
////练习1：
//struct S1
//{
//	char c1;  //0
//	int a;    //4567
//	char c2;  //8
//};     //9<3*4-------->12
//
//
////练习2：
//struct S2
//{
//	char c1;  //0
//	char c2;  //1
//	int a;    //4567
//};     //8=2*4-------->8
//
//
////练习3：
//struct S3
//{
//	double d; //01234567
//	char c;   //8
//	int i;    //12 13 14 15
//};       //16=2*8------------->16
//
//
////练习4：
//struct S4
//{
//	char c1;     //0
//	struct S3 s3;//8 9 10 ...22 23（S3类型占16字节,S3中成员最大对齐数为8，所以这里偏移量为8）
//	double d;    //24 25 ...30 31
//};       //32=2*16----------------------->32
//
//
//
//
//int main()
//{
//	struct S1 s1 = { 0 };
//	struct S2 s2 = { 0 };
//	struct S3 s3 = { 0 };
//	struct S4 s4 = { 0 };
//	printf("%d %d %d %d", sizeof(s1), sizeof(s2), sizeof(s3), sizeof(s4));//12 8 16 32
//	return 0;
//}






//////////  百度笔试题：
//////////写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//////ofsrtof(结构体类型，成员名)，如下，计算偏移量
//
//#include<stddef.h>
//struct S
//{
//	char c;
//	int i;
//	double d;
//};
//int main()
//{
//	////offset:偏移量
//	//offsetof()计算并返回结构体成员相对起始位置的偏移量
//
//	//offsrtof();//是宏，参数可以传类型----对应头文件<stddef.h>
//	printf("%d\n", offsetof(struct S, c));//0
//	printf("%d\n", offsetof(struct S, i));//4
//	printf("%d\n", offsetof(struct S, d));//8
//
//	return 0;
//}

















////////////////////        5.结构体传参


































////////////////////        6.结构体实现位段（位段的填充&可移植性）
/////////////////////////////////////////////////////////////////////////枚举////////////////////////////////////////////////////////////////////////////////
////////////////////        1.枚举类型的定义
////////////////////        2.枚举的优点
////////////////////        3.枚举的使用
//////////////////////////////////////////////////////////////////////////联合////////////////////////////////////////////////////////////////////////////////
////////////////////        1.联合类型的定义
////////////////////        2.联合的特点
////////////////////        3.联合大小的计算