#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>







//// 本章重点：
//////  为什么存在动态内存分配
//////  动态内存函数的介绍
////      malloc
////      free
////      calloc
////      realloc
//////  常见的动态内存错误
//////  几个经典的笔试题
//////  柔性数组










////////////////////////  为什么存在动态内存分配



////内存区域
////栈区（局部变量、函数的形式参数）
////堆区（动态内存分配）
////静态区（全局变量、静态变量(stating int a = 10)）



////////1.创建一个变量
////////局部变量 - 栈区
////////全局变量 - 静态区
////
////////2.创建一个数组
////////局部数组 - 栈区
////////全局数组 - 静态区
////
////
////////但是上述的开辟空间的方式有两个特点：
////////1.空间开辟大小是固定的
////////2.数组在声明时，必须指定数组长度，它所需要的内存在编译时分配
//
//////int main()
//////{
//////	int arr[50] = { 0 };
//////	//数组声明时，[]内元素个数必须为常量
//////	return 0;
//////}
////////C语言可以创建变长数组(声明数组时[]内放变量) - C99中增加的规则
////////但不是所有编译器都用C99标准，所以代码不能这么写




////  为什么存在动态内存分配？ 
// 
////////对于空间的需求，不仅仅是上述的情况，有时我们需要的空间大小在程序运行的时候才能知道，
////////那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态内存开辟了。（在堆上开辟空间）












 
////////////////////////   动态内存函数的介绍 
////  malloc、free、calloc、realloc
////  头文件 <stdlib.h> 或 <malloc.h> 

//// malloc : memory(内存) + allocate(分配)
//// calloc : clear(清零) + allocate(分配)
//// realloc : re(前缀:重新) + allocate(分配)








////////////////////  malloc() 
////// 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针 
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
//////  malloc：memory(内存) + allocate(分配) 
//  
////// 声明：void *malloc( size_t size );//要申请空间的字节大小
// 
////// 返回值：如果开辟成功，则返回一个指向开辟好的空间的(void*)类型指针.
//////         如果开辟失败，即电脑内存不足以存放开辟的空间时，则返回NULL。因此malloc的返回值一定要做检查。
//////                      （比如电脑只有4G空间，该函数却想要申请8G，申请失败，返回NUll）
//////         如果参数size为0，malloc的行为是标准未定义的，取决于编译器
//
// 
////// malloc()和free成对使用()




////////////////////  free()
////// 释放和回收一个动态内存块
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
//  
////// 声明：void free( void *memblock );//要释放的内存块的首地址
// 
//////   free函数释放先前通过调用calloc、malloc或realloc分配的内存块(memblock)。
//////   释放的字节数等价于分配块(或在realloc情况下重新分配)时请求的字节数。
//////   如果要释放的内存块地址指向NULL，则忽略指针并立即跳出该函数，什么都不干。
//////   试图释放无效指针(不是动态开辟的指针)时，free函数的行为是未定义的，可能会影响后续的分配请求并导致错误。




//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>
//
//int main()
//{
//	//向内存申请10个整型空间
//	int* p = (int*)malloc(10 * sizeof(int));
//
//	if (p == NULL)
//	{
//		//打印错误原因的一种方式
//		printf("%s\n", strerror(errno));  //这里申请失败的话，打印 Not enough space
//		//strerror--把错误码所对应的错误信息打印出来；errno--全局的错误码
//	}
//	else //空间开辟成功
//	{
//		int i = 0;
//		for (i = 0; i < 10; i++)
//		{
//			*(p + i) = i + 1;
//		}
//		for (i = 0; i < 10; i++)
//		{
//			printf("%d ", *(p + i));
//		}
//	}
//
//	//当动态申请的空间不再使用时
//	//应该把内存还给操作系统
//	free(p);
//	//指针p指向的空间被释放后，p仍然有能力找到这块空间,即p变成了[野指针]
//	p = NULL;//要把p赋为空指针，防止误用野指针
//
//	return 0;
//}














////////////////////  calloc() 
////// 在内存中开辟一块的空间，将其空间中【元素初始化为0】,并返回指向这块空间的void*
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
////// calloc：clear(清零) + allocate(分配) 
//  
////// 声明：void *calloc( size_t num, size_t size );//元素个数，元素大小
// 
////// 返回值：如果开辟成功，则返回一个指向开辟好的空间的(void*)类型指针.
//////         如果开辟失败（内存不够用），则返回NULL。因此calloc的返回值一定要做检查。            
//////         如果参数size为0，malloc的行为是标准未定义的，取决于编译器
//
// 
////// calloc()也和free成对使用()



//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>
//
//int main()
//{
//	//malloc(10*sizeof(int))
//	int* p = calloc(10, sizeof(int));//元素与malloc的不同
//	if (p == NULL)
//	{
//		printf("%s\n", strerror(errno));
//	}
//	else 
//	{
//		int i;
//		for (i = 0; i < 10; i++)
//		{
//			//可以看出，calloc函数将开辟空间内元素初始化为0
//			printf("%d ", *(p + i));
//		}
//	}
//
//	//释放动态开辟的空间
//	free(p);
//
//	return 0;
//}














////////////////////  realloc()  
////// 调整动态内存空间的大小 / (官方解释：重新分配内存块)
 //
////// 头文件：<stdlib.h> 或 <malloc.h> 
////// realloc：re(前缀:重新) + allocate(分配)
//  
// 
////// 声明：void *realloc( void *memblock, size_t size );
////// [memblock] 是要调整的内存块的地址
////// [size]     是调整之后内存的新大小
////// [返回值]   为调整之后的内存起始位置
//
//
////// 情景 1.如果p指向的空间之后【有足够大的内存可以追加】，则新增的空间【直接追加】在这块空间后面，最后返回的【地址不变】
////// 情景 2.如果p指向的空间之后【没有足够的内存空间来追加】，则realloc函数会找新的内存区域来开辟一块满足需求的空间，
//////        并且把原来内存中的【数据拷贝到新内存中】，并【自动释放旧的内存空间】，最后返回新开辟的内存空间的【新地址】
////// 情景 3.若是剩余内存【不够开辟新空间】，则开辟失败，【返回NULL】
//////       （所以为了防止之前的旧地址被NULL替代，需要先使用一个新的变量接收该函数返回值并判断是否为空指针，而不能直接赋值）





#include<stdlib.h>
#include<string.h>
#include<errno.h>

int main()
{

	int* p = (int*)malloc(20);


	if (p == NULL)//判断是否开辟成功
	{
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 5; i++)//修改调整前的空间
		{
			*(p + i) = i + 1;
		}
	}
	//上面只是在使用malloc开辟的20字节的空间


	//假设这里20字节不能满足我们使用，我们希望有40个字节的空间
	//在这里就可以使用realloc来调整动态开辟的内存
	//
	//realloc使用时的注意事项
	//情景 1.如果p指向的空间之后【有足够大的内存可以追加】，则新增的空间【直接追加】在这块空间后面，最后返回的【地址不变】
	//情景 2.如果p指向的空间之后【没有足够的内存空间来追加】，则realloc函数会找新的内存区域来开辟一块满足需求的空间，
	//       并且把原来内存中的【数据拷贝到新内存中】，并【自动释放旧的内存空间】，最后返回新开辟的内存空间的【新地址】
	//情景 3.若是剩余内存【不够开辟新空间】，则开辟失败，【返回NULL】
	//      （所以为了防止之前的旧地址被NULL替代，需要先使用一个新的变量接收该函数返回值并判断是否为空指针，而不能直接赋值）

	int* ptr = (int*)realloc(p, 40);//大小调整为40字节

	if (ptr != NULL)//判断realloc返回值是否为NULL
	{
		p = ptr;

		int i;
		for (i = 5; i < 10; i++)//修改调整后的空间
		{
			*(p + i) = i + 1;
		}

		for (i = 0; i < 10; i++)//打印修改后的空间
		{
			printf("%d", *(p + i));
		}

	}

	//释放动态开辟的空间
	free(p);
	p = NULL;

	return 0;
}




















////////////////////////  常见的动态内存错误

////////////////////////  几个经典的笔试题

////////////////////////  柔性数组