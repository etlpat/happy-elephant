#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>




 //////本章重点
////・程序的翻译环境
////・程序的运行环境
////・详解：C语言程序的编译+链接
////・预定义符号介绍
////・预处理指令#define
////・宏和函数的对比
////・预处理操作符#和##的介绍
////・命令定义
////・预处理指令#include
////・预处理指令#undef
////・条件编译













//下面是代码跑起来的整个过程：

////  C代码-文本文件                                机器指令-二进制文件
////  test.c(源程序)  -------编译-----链接------->  test.exe(可执行程序) ---> 运 行
////               |     翻    译    环    境      |                   |  运  行  环  境  |



////////////////////////程序的翻译环境和执行环境
//// 
////在ANSI C(标准C语言)的任何一种实现中，都存在两个不同的环境
////第一个是【翻译环境】，在这个环境中源代码被转换为可执行的机器指令
////第二个是【执行环境】，它用于实际执行代码







 
////////////////////  ・程序的【翻译环境】
////////////////////  ・详解：C语言程序的编译+链接


//////源文件，经过编译器的【编译】处理，和链接器的【链接】处理，生成可执行程序
// 
//・【编译】：组成一个程序的的每个源文件(.c)都会经过【编译器】处理，分别转换成目标文件(.obj)。  -- object 目标,对象
//          *（编译作用）：把每个文件的C语言转化为机器语言(二进制)
// 
//・【链接】：每个目标文件(.obj)，再加上一个链接库，经过【链接器(linker)】的处理，形成单一完整的可执行程序(.exe)。  --executable 可执行的
// 注意：连接器会同时引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员的个人程序库，将其需要的函数也链接到程序中。
//          *（链接作用）：把所有文件中的机器语言汇总到一个文件中



////以下为详细解读：

////*【编译】又分为三个阶段：【预编译/预处理】、【编译】、【汇编】
// 
// 
//////【预编译/预处理】：对test.c文件进行【文本操作】，生成test.i文件，具体如下
////         （文本操作）1.#include - 头文件的包含（把头文件展开，还原为C库中代码）
////                     2.注释删除 - 使用空格替换注释
////                     3.#define -  替换为对应的数值
// 
//////【编译】：把test.i的【C语言代码翻译为汇编代码】，生成test.s文件
////   （C代码翻译为汇编代码）1.语法分析
////                          2.词法分析 - 《编译原理》
////                          3.语义分析
////                          4.符号汇总
// 
//////【汇编】：把test.s的【汇编代码转换为二进制代码】，生成目标文件test.o (.obj)
////   （汇编代码转换为二进制代码）1.形成符号表
////                               2.汇编指令->二进制指令



////*【链接】
////1.合并段表
////2.符号表的合并和重定位






////////////////////  ・程序的运行环境


////一个程序已经形成了.exe的可执行文件，之后怎么运行起来呢？
// 
// 
////程序执行的过程：
// 
////1.程序必须载入内存中。
////      在有操作系统时：这个步骤由操作系统完成；
////      在独立环境中，程序的载入要由手工完成，也可能是通过可执行代码置入只读内存来完成。
// 
////2.程序的执行便开始了。接着便调用main函数
// 
////3.开始执行代码。这个时候程序将使用栈、堆、静态内存来存储其对应的数据。
// 
////4.终止程序。正常终止程序或意外终止。




















////////////////////  ・预定义(预处理)符号介绍


//预定义符号
// __FILE__ 进行编译的源文件
// __LINE__ 这个符号当前在第几行
// __FUNCTION__ 这个符号当前在哪个函数中
// __DATE__ 文件被编译的日期
// __TIME__ 文件被编译的日期
// __STDC__ 如果编译器遵循ANSI C，其值为1，否为未定义
//
//这些预定义符号都是语言内置的，使用例子如下



//int main()
//{
//	printf("%s\n", __FILE__);//打印出该源文件的文件名(文件路径+文件名主干+文件后缀)：C:\Users\lenovo\source\repos\test - 1\test - 1\16.（进阶）程序环境和预处理.c
//	printf("%d\n", __LINE__);//打印出了这一行的标号：152
//	printf("%s\n", __FUNCTION__);//打印出了现在所在的函数：main
//	printf("%s\n", __DATE__);//打印出了文件编译的日期：Dec 12 2022
//	printf("%s\n", __TIME__);//打印出了文件编译的时间：11:33:26
//
//	return 0;
//}



////具体使用方法:把这些标记写入文件
//int main()
//{
//	int i = 0;
//	int arr[10] = { 0 };
//	FILE* pf = fopen("test.txt", "w");
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i + 1;
//		fprintf(pf, "file:%s  line:%d  date:%s  time:%s  i=%d", __FILE__, __LINE__, __DATE__, __TIME__, i);
//	}
//
//	fclose(pf);
//	pf = NULL;
//
//	return 0;
//}




















////////////////////  ・预处理指令#define
//// #define - 定义标识符/定义宏



///////////////     【 #define 定义标识符 】
// 
//// 语法：#define name stuff
//
// 
// 
////以下为例子
//#define MAX  100
//#define STR  "hehe" 
//#define REG  register        //为 register 这个关键字，创建一个简短的名字
//#define do_forever  for(;;)  //用更形象的符号来替换一种实现
//#define CASE  break;case     //在写case语句的时候自动把break加上 
//
// 
//// define定义标识符常量在预编译是转化为其对应的值/表达式/语句
//// 注意，define的定义中习惯最好不要加分号，防止语法错误而不自知。要加的时候也可以加。



//#define MAX  100
//#define STR  "hehe" 
//#define REG  register       
//#define do_forever  for(;;)
//#define CASE  break;case   
//
//int main()
//{
//	printf("%d\n", MAX);//100    //在预编译时转化为对应的值
//	printf("%s\n", STR);//hehe
//	REG int a;//这种写法相当于 register int a;
//
//	do_forever; //相当于在这里放了一个 for(;;);
//
//	return 0;
//}







///////////////     【 #define 定义宏 】
//// #defint 机制包含了一个规定，允许把参数替换到文本中，这种实现通常称为宏(macro)或定义宏(define macro)
//
// 
//
//// 下面是宏的声明方式
//// 【  #define name(parament-list) stuff  】     其中parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中
//
//// 注意：1.参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分
////       2.定义宏时不要吝啬括号，因为宏的运算是直接替换
////         ・加括号，避免在使用宏时，由于[参数中操作符]或[临近操作符]之间不可预料的相互作用，搅乱运算顺序。
//
//
//
//// 例如：
//// #define SQUARE(X)  ((X) * (X))
//// #define ADD(X)  ((X) + (X))
//
//
//
//// 在程序中拓展 #define 定义符号和宏时，需要涉及几个步骤
////   1.在调用时，首先多参数进行检查，看看是否包含任何由#define定义的符号。如果时，她们优先被替换。
////   2.调换文本随后被插入到程序原来文本的位置。对于宏，参数名被它们的值替换。
////   3.最后，再次对结果文件进行扫描，看看它们是否包含任何由#define定义的符号。如果是，就重复上述过程
//
//
//// 特别提醒：
//// 1.宏参数和 #define定义中可以出现其他 #define定义的变量，但对于宏，不能出现递归
//// 2.当预处理器搜索 #define定义的符号时，字符串常量的内容并不被搜索
////   就是说假定有宏ADD，但是字符串"ADD"，字符串内ADD为字符串本身的内容，不被替换




////例1：
//
//#define SQUARE(X) X*X
//#define SQUARE1(X) (X)*(X)
//
//int main()
//{
//	int ret = SQUARE(5);
//	printf("%d\n", ret);//25
//
//	//写宏的时候不要吝啬括号
//
//	int ret1 = SQUARE(5 + 1);
//	printf("%d\n", ret1);// 11  宏是在预编译的时候直接替换到当前函数内的，这里替换后变为 5 + 1*5 + 1
//
//	int ret2 = SQUARE1(5 + 1);
//	printf("%d\n", ret2);// 36  宏的声明时添加括号后，替换为 (5 + 1)*(5 + 1)
//
//	return 0;
//}



////例2：
//
//#define DOUBLE(X) (X)+(X)
//#define DOUBLE1(X) ((X)+(X))
//
//int main()
//{
//	int a = 5;
//	int ret = 10 * DOUBLE(a);
//	printf("%d\n", ret);// 55  这是因为替换为 10 * (a) + (a)
//
//	int ret1 = 10 * DOUBLE1(a);
//	printf("%d\n", ret1);// 100  这里替换为 10 * ((a) + (a))
//
//	return 0;
//}



//////写宏的时候不要吝啬括号
// 
//总结1：当【宏的参数为表达式】，当(宏参数的表达式内操作符优先级)和(宏内的操作符优先级)不同时，可能导致表达式的计算顺序发生意外
//     ・定义宏时，宏的参数添加括号，将参数变成独立的部分，明确的指定计算顺序。
//总结2：当【宏在表达式中时】，当(宏所在的表达式中操作符优先级)和(宏内的操作符优先级)不同时，也可能影响运算结果
//     ・定义宏时，宏整体添加括号，防止替换后宏以外操作符影响宏内结果





















 

////////////////////  ・预处理操作符#和##的介绍
////////////////////  ・命令定义
////////////////////  ・预处理指令#include
////////////////////  ・预处理指令#undef
////////////////////  ・条件编译








